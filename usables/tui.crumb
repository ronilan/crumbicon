run = { components state ->
  // ** utility function
  list_to_string = { arr -> <- (reduce arr {accum item _ -> <- (join accum (string item))} "")}

  string_to_list = { str -> <- (map (range (length str)) {index _ -> <- (get str index)}) }

  string_pad_start = { str count padder -> 
    <- (if (greater_than (add (length str) 1) count){
      <- str
    } {
      <- (join (list_to_string (map (range (subtract count (length str))) {_ _ -> <- padder})) str)
    })
  }

  string_pad_end = { str count padder -> 
    <- (if (greater_than (add (length str) 1) count){
      <- str
    } {
      <- (join str (list_to_string (map (range (subtract count (length str))) {_ _ -> <- padder})))
    })
  }

  // mouse calculation
  // component: a list describing a tui component
  // mouse_xy: a list with current  x y mouse position
  mouse_over = { component mouse_xy ->
    // deconstruct for readability
    props = (get component 1)
    
    x = (get props 0)
    y = (get props 1)
    width = (get props 2)
    height = (get props 3)

    row = (integer (get mouse_xy 1))
    column = (integer (get mouse_xy 0))

    // by calculating the position of on the screen 
    // decide if the mouse is over the component. 
    <- (if (and
        (and 
          (greater_than column (subtract x 1))
          (less_than column (add x width 0))
        )
        (and 
          (greater_than row (subtract y 1))
          (less_than row (add y height 0))
        )
      )
    {
      <- 1
    } {
      <- void
    })
  }

  // drawing components
  draw = { component ->
    // deconstruct for readability
    props = (get component 1)

    // all calculations are on a screen where top left is 0, 0
    // escape codes are on a system based on 1, 1
    x = (add (get props 0) 1)
    y = (add (get props 1) 1)
    width = (get props 2)
    height = (get props 3)

    component_look = (get component 0)

    // jump to mouse_xy
    (print (join "\e[" (string y) ";" (string x) "H"))

    // print cell by cell
    (loop height { j ->
      (loop width { i ->
        (print (get component_look (add (multiply j width) i) ))
      })
      // jump to position for each row
      (print (join "\e[" (string (add y j 1)) ";" (string x) "H"))
    })
  }

  // ** setup

  // hide cursor
  (print "\e[?25l")
  // clear
  (print "\e[2J\e[H")
  // initial render
  (loop (length components) { i -> 
    (draw (get components i))
  })
 
  // event loop
  result = (use "./usables/event-loop.crumb" { 
    <- (start components state)
  })


  // ** tear down
  // hide cursor
  (print "\e[?25h")
  // clear
  (print "\e[2J\e[H")

  <- (get result 1)
}

